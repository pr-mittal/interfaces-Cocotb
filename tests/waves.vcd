$date
	Mon Mar 20 15:53:55 2023
$end
$version
	Icarus Verilog
$end
$timescale
	1ps
$end
$scope module dut_test $end
$var wire 1 ! CLK $end
$var wire 1 " RST_N $end
$var wire 1 # busy $end
$var wire 1 $ busy_D_IN $end
$var wire 8 % cfg_address [7:0] $end
$var wire 32 & cfg_data_in [31:0] $end
$var wire 1 ' cfg_en $end
$var wire 1 ( cfg_op $end
$var wire 1 ) cfg_rdy $end
$var wire 1 * din_en $end
$var wire 8 + din_value [7:0] $end
$var wire 1 , dout_en $end
$var wire 1 - dout_ff_FULL_N $end
$var wire 1 . len_en $end
$var wire 8 / len_value [7:0] $end
$var wire 1 0 programmed_length_EN $end
$var wire 1 1 normal_mode_RESET_N $end
$var wire 1 2 len_rdy $end
$var wire 8 3 dout_value [7:0] $end
$var wire 1 4 dout_rdy $end
$var wire 1 5 din_rdy $end
$var wire 32 6 cfg_data_out [31:0] $end
$scope module dut $end
$var wire 1 ! CLK $end
$var wire 1 7 \MUX_programmed_length$write_1__SEL_1 $end
$var wire 1 " RST_N $end
$var wire 1 8 \busy$D_IN $end
$var wire 1 9 \busy$EN $end
$var wire 8 : cfg_address [7:0] $end
$var wire 32 ; cfg_data_in [31:0] $end
$var wire 1 ' cfg_en $end
$var wire 1 ( cfg_op $end
$var wire 1 ) cfg_rdy $end
$var wire 8 < \current_count$D_IN [7:0] $end
$var wire 1 = \current_count$EN $end
$var wire 1 * din_en $end
$var wire 1 5 din_rdy $end
$var wire 8 > din_value [7:0] $end
$var wire 1 , dout_en $end
$var wire 1 ? \dout_ff$CLR $end
$var wire 1 @ \dout_ff$DEQ $end
$var wire 1 A \dout_ff$ENQ $end
$var wire 1 4 dout_rdy $end
$var wire 8 B dout_value [7:0] $end
$var wire 1 . len_en $end
$var wire 1 2 len_rdy $end
$var wire 8 C len_value [7:0] $end
$var wire 1 D \pause$EN $end
$var wire 1 E \programmed_length$EN $end
$var wire 1 F \sum$EN $end
$var wire 1 G \sw_override$EN $end
$var wire 1 H \w_sw_override$whas $end
$var wire 17 I x__h969 [16:0] $end
$var wire 1 J \sw_override$D_IN $end
$var wire 8 K \sum$D_IN [7:0] $end
$var wire 8 L \programmed_length$D_IN [7:0] $end
$var wire 1 M \pause$D_IN $end
$var wire 8 N next_count__h523 [7:0] $end
$var wire 1 O \dout_ff$FULL_N $end
$var wire 1 P \dout_ff$EMPTY_N $end
$var wire 8 Q \dout_ff$D_OUT [7:0] $end
$var wire 8 R \dout_ff$D_IN [7:0] $end
$var wire 1 S current_count_PLUS_1_EQ_programmed_length___d8 $end
$var wire 32 T cfg_data_out [31:0] $end
$var reg 32 U CASE_cfg_address_0_0_CONCAT_x69_4_0_CONCAT_sw__ETC__q1 [31:0] $end
$var reg 1 V busy $end
$var reg 8 W current_count [7:0] $end
$var reg 1 X pause $end
$var reg 8 Y programmed_length [7:0] $end
$var reg 8 Z sum [7:0] $end
$var reg 1 [ sw_override $end
$scope module dout_ff $end
$var wire 1 ! CLK $end
$var wire 1 ? CLR $end
$var wire 1 @ DEQ $end
$var wire 8 \ D_IN [7:0] $end
$var wire 1 P EMPTY_N $end
$var wire 1 A ENQ $end
$var wire 1 O FULL_N $end
$var wire 1 " RST $end
$var wire 1 ] d0d1 $end
$var wire 1 ^ d0di $end
$var wire 1 _ d0h $end
$var wire 1 ` d1di $end
$var wire 8 a D_OUT [7:0] $end
$var reg 8 b data0_reg [7:0] $end
$var reg 8 c data1_reg [7:0] $end
$var reg 1 d empty_reg $end
$var reg 1 e full_reg $end
$scope begin error_checks $end
$var reg 1 f deqerror $end
$var reg 1 g enqerror $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
0g
0f
1e
0d
b10101010 c
b10101010 b
b10101010 a
0`
1_
0^
0]
bx \
0[
b10101010 Z
b10101010 Y
0X
b10101010 W
0V
b10101010 U
b0x0x0x0x0 T
0S
bx R
b10101010 Q
0P
1O
b10101011 N
zM
bz L
bx K
zJ
b1010101010101010 I
xH
xG
xF
xE
xD
bz C
b10101010 B
0A
z@
0?
bz >
x=
b10101011 <
bz ;
bz :
x9
18
x7
b0x0x0x0x0 6
15
04
b10101010 3
02
11
z0
bz /
z.
1-
z,
bz +
z*
1)
z(
z'
bz &
bz %
z$
0#
1"
1!
$end
#1000
05
x8
b0 6
b0 T
b0 U
b0 Z
b0 Y
b1 <
b1 N
b0 I
b0 W
0"
#2500
0!
#5000
1!
#5001
